<!doctype html>
<html lang="id">
<head>
    <meta charset="utf-8" />
    <title>Virtual Gallery — Camera Planner (Fix)</title>
    <style>
        html, body {
            margin: 0;
            height: 100%;
            overflow: hidden;
            background: #111;
        }
        #hud {
            position: fixed;
            top: 8px;
            left: 8px;
            z-index: 10;
            color: #eee;
            font: 14px/1.4 system-ui;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 10px;
            border-radius: 8px;
        }
        #hud button {
            margin-right: 8px;
        }
        #labels {
            position: fixed;
            bottom: 8px;
            left: 8px;
            color: #bbb;
            font: 12px system-ui;
        }
    </style>
   <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="hud">
        <button id="presetClose">Shot: Dekat</button>
        <button id="presetMedium">Shot: Menengah</button>
        <button id="presetWide">Shot: Lebar</button>
        <span style="margin-left:10px">Zoom vs Dolly:
            <button id="zoomIn">Zoom+</button>
            <button id="zoomOut">Zoom−</button>
            <button id="dollyIn">Dolly-</button>
            <button id="dollyOut">Dolly+</button>
        </span>
    </div>
    <div id="labels">Kiri: Perspective • Kanan: Orthographic (top-down) + CameraHelper</div>
  <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";

        let renderer, scene;
        let camPersp, camOrtho, controlsPersp, helper;
        let width = 0, height = 0;

        console.log('THREE revision:', THREE.REVISION);
        init();
        animate();

        function init() {
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            document.body.appendChild(renderer.domElement);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x111111, 1);
            renderer.shadowMap.enabled = true;
            renderer.autoClear = false; // penting untuk multi-viewport
            // renderer.outputColorSpace = THREE.SRGBColorSpace; // opsional untuk warna

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            // Lights (lebih terang)
            const amb = new THREE.AmbientLight(0xffffff, 0.35);
            scene.add(amb);
            const dir = new THREE.DirectionalLight(0xffffff, 1.2);
            dir.position.set(6, 9, 6);
            dir.castShadow = true;
            dir.shadow.mapSize.set(1024, 1024);
            dir.shadow.bias = -0.0005;
            scene.add(dir);
           // Room (inverted)
            const room = new THREE.Mesh(
                new THREE.BoxGeometry(10, 6, 10),
                new THREE.MeshStandardMaterial({
                    color: 0x3a3a3a,
                    roughness: 0.9,
                    metalness: 0.0,
                    side: THREE.BackSide
                })
            );
            room.receiveShadow = true;
            scene.add(room);

            // Floor
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 10),
                new THREE.MeshStandardMaterial({
                    color: 0x505050,
                    roughness: 1.0
                })
            );
            floor.rotation.x = -Math.PI/2;
            floor.position.y = -3;
            floor.receiveShadow = true;
            scene.add(floor);

            // 3 patung
            const bright = (hex) => new THREE.MeshStandardMaterial({
                color: hex,
                metalness: 0.2,
                roughness: 0.4
            });

            const statueA = new THREE.Mesh(
                new THREE.TorusKnotGeometry(0.5, 0.18, 120, 16),
                bright(0x9ed1ff)
            );
            statueA.position.set(-2, -2.2, -1);
            statueA.castShadow = true;
            scene.add(statueA);

            const statueB = new THREE.Mesh(
                new THREE.SphereGeometry(0.8, 48, 32),
                bright(0xffb6d5)
            );
            statueB.position.set(0, -2.2, 2);
            statueB.castShadow = true;
            scene.add(statueB);

            const statueC = new THREE.Mesh(
                new THREE.ConeGeometry(0.7, 1.8, 48),
                bright(0xc7ffb6)
            );
            statueC.position.set(2.2, -2.1, -0.5);
            statueC.castShadow = true;
            scene.add(statueC);
           // Fokus kamera (karya tengah)
            const focus = new THREE.Vector3(0, -2.2, 2);

            // Cameras
            camPersp = new THREE.PerspectiveCamera(60, 1, 0.1, 200);
            camPersp.position.set(0, 0.8, 6);
            camPersp.lookAt(focus);

            const aspect = 1; // akan diupdate
            const orthoH = 6;
            camOrtho = new THREE.OrthographicCamera(
                -orthoH * aspect,
                orthoH * aspect,
                orthoH,
                -orthoH,
                0.1,
                200
            );
            camOrtho.position.set(0, 8.5, 0);
            camOrtho.up.set(0, 0, -1);
            camOrtho.lookAt(0, 0, 0);

            // Controls
            controlsPersp = new OrbitControls(camPersp, renderer.domElement);
            controlsPersp.enableDamping = true;
            controlsPersp.dampingFactor = 0.05;
            controlsPersp.target.copy(focus);

            // CameraHelper untuk melihat frustum kamera perspektif
            helper = new THREE.CameraHelper(camPersp);
            scene.add(helper);

            // UI
            byId('presetClose').onclick = () => setShot('close', focus);
            byId('presetMedium').onclick = () => setShot('medium', focus);
            byId('presetWide').onclick = () => setShot('wide', focus);
            byId('zoomIn').onclick = () => zoomDelta(-5);
            byId('zoomOut').onclick = () => zoomDelta(+5);
            byId('dollyIn').onclick = () => dolly(-0.5);
            byId('dollyOut').onclick = () => dolly(+0.5);

            // Resize
            onResize();
            window.addEventListener('resize', onResize);

            // Default shot
            setShot('medium', focus);
            console.log('Canvas size:', width, height);

            // ————— helpers —————
            function setShot(kind, target) {
                if (kind === 'close') {
                    camPersp.fov = 35;
                    camPersp.position.copy(target).add(new THREE.Vector3(0.4, 0.25, 1.4));
                } else if (kind === 'medium') {
                    camPersp.fov = 55;
                    camPersp.position.copy(target).add(new THREE.Vector3(1.2, 0.8, 3.2));
                } else {
                    camPersp.fov = 75;
                    camPersp.position.copy(target).add(new THREE.Vector3(2.2, 1.0, 6.0));
                }
                camPersp.lookAt(target);
                controlsPersp.target.copy(target);
                camPersp.updateProjectionMatrix();
                helper.update();
            }

            function zoomDelta(dfov) {
                camPersp.fov = THREE.MathUtils.clamp(camPersp.fov + dfov, 25, 90);
                camPersp.updateProjectionMatrix();
                helper.update();
            }

            function dolly(delta) {
                const dir = new THREE.Vector3();
                camPersp.getWorldDirection(dir);
                camPersp.position.addScaledVector(dir, delta);
                controlsPersp.target.addScaledVector(dir, delta);
                helper.update();
            }

            function byId(id) {
                return document.getElementById(id);
            }
        }
      function onResize() {
            width = window.innerWidth;
            height = window.innerHeight;
            renderer.setSize(width, height);

            // Update aspek untuk kedua kamera (split 50:50)
            camPersp.aspect = Math.max(1e-6, (width * 0.5) / height);
            camPersp.updateProjectionMatrix();

            const aspectRight = Math.max(1e-6, (width * 0.5) / height);
            const orthoH = 6;
            camOrtho.left = -orthoH * aspectRight;
            camOrtho.right = orthoH * aspectRight;
            camOrtho.top = orthoH;
            camOrtho.bottom = -orthoH;
            camOrtho.updateProjectionMatrix();
        }

        function animate() {
            requestAnimationFrame(animate);
            controlsPersp.update();

            // Multi-viewport render
            renderer.clear(true, true, true); // penting: bersihkan sebelum render sequence
            renderer.setScissorTest(true);

            // LEFT: Perspective
            const wL = Math.floor(width * 0.5), h = height;
            renderer.setViewport(0, 0, wL, h);
            renderer.setScissor(0, 0, wL, h);
            renderer.setClearColor(0x151515, 1);
            renderer.render(scene, camPersp);

            // RIGHT: Ortho + helper
            const wR = Math.floor(width * 0.5);
            renderer.setViewport(wL, 0, wR, h);
            renderer.setScissor(wL, 0, wR, h);
            renderer.setClearColor(0x101010, 1);
            helper.visible = true;
            renderer.render(scene, camOrtho);
            renderer.setScissorTest(false);
        }
    </script>
</body>
</html>
